// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package schema

import (
	"context"
	"database/sql"
	"time"
)

const getPersonAverage = `-- name: GetPersonAverage :many
SELECT
    dlk.wca_id      AS wca_id,
    ct.wca_name     AS name,
    al.state_id     AS state_id,
    CASE WHEN ru.wca_id is not null THEN true ELSE false END AS registered,
    dlk.event_id    AS event_id,
    dlk.ranking     AS ranking,
    dlk.average     AS best,
    comp.id         AS competition_id,
    comp.name       AS competition_name,
    comp2.state_id  AS competition_state,
    -- dmp.roundTypeId AS round,
    dmp.value1      AS time_1,
    dmp.value2      AS time_2,
    dmp.value3      AS time_3,
    dmp.value4      AS time_4,
    dmp.value5      AS time_5,
    STR_TO_DATE(CONCAT(comp.year, ',', comp.endMonth, ',', comp.endDay), '%Y,%m,%d') AS ts
FROM
    datalake.ranking_average dlk
        LEFT JOIN datalake.competitors ct on (dlk.wca_id = ct.wca_id)
        LEFT JOIN datalake.all_persons_with_states al on (dlk.wca_id = al.wca_id)
        LEFT JOIN app.registered_users ru on (dlk.wca_id = ru.wca_id)
        LEFT JOIN dump.Results dmp on (dlk.wca_id = dmp.personId and dlk.event_id = dmp.eventId)
        LEFT JOIN dump.Competitions comp on (dmp.competitionId = comp.id)
        LEFT JOIN datalake.competitions comp2 on (dmp.competitionId = comp2.competition_id)
WHERE
    dlk.average = dmp.average
    AND dlk.wca_id = ?
`

type GetPersonAverageRow struct {
	WcaID            string
	Name             sql.NullString
	StateID          sql.NullString
	Registered       int32
	EventID          string
	Ranking          int32
	Best             sql.NullInt32
	CompetitionID    sql.NullString
	CompetitionName  sql.NullString
	CompetitionState sql.NullString
	Time1            sql.NullInt32
	Time2            sql.NullInt32
	Time3            sql.NullInt32
	Time4            sql.NullInt32
	Time5            sql.NullInt32
	Ts               time.Time
}

func (q *Queries) GetPersonAverage(ctx context.Context, wcaid string) ([]GetPersonAverageRow, error) {
	rows, err := q.db.QueryContext(ctx, getPersonAverage, wcaid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPersonAverageRow
	for rows.Next() {
		var i GetPersonAverageRow
		if err := rows.Scan(
			&i.WcaID,
			&i.Name,
			&i.StateID,
			&i.Registered,
			&i.EventID,
			&i.Ranking,
			&i.Best,
			&i.CompetitionID,
			&i.CompetitionName,
			&i.CompetitionState,
			&i.Time1,
			&i.Time2,
			&i.Time3,
			&i.Time4,
			&i.Time5,
			&i.Ts,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPersonInfo = `-- name: GetPersonInfo :one
SELECT
    ct.wca_name AS name,
    al.state_id AS state_id,
    CASE WHEN ru.wca_id IS NOT NULL THEN true ELSE false END AS registered,
    cb.n_competitions AS state_competitions,
    cb2.total AS total_competitions
FROM
    datalake.competitors ct
        LEFT JOIN app.registered_users ru ON ru.wca_id = ct.wca_id
        LEFT JOIN datalake.all_persons_with_states al on ct.wca_id = al.wca_id
        LEFT JOIN datalake.competitions_by_person_and_state cb ON cb.wca_id = ct.wca_id
        LEFT JOIN (
            SELECT personId, COUNT(DISTINCT competitionId) AS total
            FROM dump.Results
            WHERE personId = ?
        ) as cb2 ON cb2.personId = ct.wca_id
WHERE
    ct.wca_id = ?
`

type GetPersonInfoParams struct {
	Wcaid string
}

type GetPersonInfoRow struct {
	Name              string
	StateID           sql.NullString
	Registered        int32
	StateCompetitions sql.NullInt32
	TotalCompetitions int64
}

func (q *Queries) GetPersonInfo(ctx context.Context, arg GetPersonInfoParams) (GetPersonInfoRow, error) {
	row := q.db.QueryRowContext(ctx, getPersonInfo, arg.Wcaid, arg.Wcaid)
	var i GetPersonInfoRow
	err := row.Scan(
		&i.Name,
		&i.StateID,
		&i.Registered,
		&i.StateCompetitions,
		&i.TotalCompetitions,
	)
	return i, err
}

const getPersonResults = `-- name: GetPersonResults :many
SELECT
    rs.event_id                 AS event,
    COALESCE(rs.single, 0)      AS single,
    rs.ranking                  AS ranking_single,
    COALESCE(ra.average,0)      AS average,
    ra.ranking                  AS ranking_average
FROM
    datalake.ranking_single rs
        JOIN datalake.ranking_average ra
            ON rs.wca_id = ra.wca_id
            AND rs.state_id = ra.state_id
            AND rs.event_id = ra.event_id
WHERE
    rs.wca_id = ?
`

type GetPersonResultsRow struct {
	Event          string
	Single         int32
	RankingSingle  int32
	Average        int32
	RankingAverage int32
}

func (q *Queries) GetPersonResults(ctx context.Context, wcaid string) ([]GetPersonResultsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPersonResults, wcaid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPersonResultsRow
	for rows.Next() {
		var i GetPersonResultsRow
		if err := rows.Scan(
			&i.Event,
			&i.Single,
			&i.RankingSingle,
			&i.Average,
			&i.RankingAverage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPersonSingle = `-- name: GetPersonSingle :many
SELECT
    dlk.wca_id      AS wca_id,
    ct.wca_name     AS name,
    al.state_id     AS state_id,
    CASE WHEN ru.wca_id is not null THEN true ELSE false END AS registered,
    dlk.event_id    AS event_id,
    dlk.ranking     AS ranking,
    dlk.single      AS best,
    comp.id         AS competition_id,
    comp.name       AS competition_name,
    comp2.state_id  AS competition_state,
    -- dmp.roundTypeId AS round,
    dmp.value1      AS time_1,
    dmp.value2      AS time_2,
    dmp.value3      AS time_3,
    dmp.value4      AS time_4,
    dmp.value5      AS time_5,
    STR_TO_DATE(CONCAT(comp.year, ',', comp.endMonth, ',', comp.endDay), '%Y,%m,%d') AS ts
FROM
    datalake.ranking_single dlk
        LEFT JOIN datalake.competitors ct on (dlk.wca_id = ct.wca_id)
        LEFT JOIN datalake.all_persons_with_states al on (dlk.wca_id = al.wca_id)
        LEFT JOIN app.registered_users ru on (dlk.wca_id = ru.wca_id)
        LEFT JOIN dump.Results dmp on (dlk.wca_id = dmp.personId and dlk.event_id = dmp.eventId)
        LEFT JOIN dump.Competitions comp on (dmp.competitionId = comp.id)
        LEFT JOIN datalake.competitions comp2 on (dmp.competitionId = comp2.competition_id)
WHERE
    dlk.single = dmp.best
    AND dlk.wca_id = ?
`

type GetPersonSingleRow struct {
	WcaID            string
	Name             sql.NullString
	StateID          sql.NullString
	Registered       int32
	EventID          string
	Ranking          int32
	Best             sql.NullInt32
	CompetitionID    sql.NullString
	CompetitionName  sql.NullString
	CompetitionState sql.NullString
	Time1            sql.NullInt32
	Time2            sql.NullInt32
	Time3            sql.NullInt32
	Time4            sql.NullInt32
	Time5            sql.NullInt32
	Ts               time.Time
}

func (q *Queries) GetPersonSingle(ctx context.Context, wcaid string) ([]GetPersonSingleRow, error) {
	rows, err := q.db.QueryContext(ctx, getPersonSingle, wcaid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPersonSingleRow
	for rows.Next() {
		var i GetPersonSingleRow
		if err := rows.Scan(
			&i.WcaID,
			&i.Name,
			&i.StateID,
			&i.Registered,
			&i.EventID,
			&i.Ranking,
			&i.Best,
			&i.CompetitionID,
			&i.CompetitionName,
			&i.CompetitionState,
			&i.Time1,
			&i.Time2,
			&i.Time3,
			&i.Time4,
			&i.Time5,
			&i.Ts,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRankingAverage = `-- name: GetRankingAverage :many
SELECT
	ra.wca_id 			AS wca_id,
	cpr.wca_name 		AS name,
	ra.state_id 		AS state_id,
	CASE WHEN ru.wca_id is not null THEN true ELSE false END AS registered,
	ra.event_id 		AS event_id,
	ra.ranking 			AS ranking,
	ra.average 			AS best,
	comp.id         	AS competition_id,
    comp.name       	AS competition_name,
    cpn.state_id  		AS competition_state,
    dmp.value1      	AS time_1,
    dmp.value2      	AS time_2,
    dmp.value3      	AS time_3,
    dmp.value4      	AS time_4,
    dmp.value5      	AS time_5,
    STR_TO_DATE(CONCAT(comp.year, ',', comp.endMonth, ',', comp.endDay), '%Y,%m,%d') AS ts
FROM
	datalake.ranking_average ra
		JOIN datalake.competitors cpr on ra.wca_id = cpr.wca_id
		LEFT JOIN app.registered_users ru on ra.wca_id = ru.wca_id
		LEFT JOIN dump.Results dmp on (ra.wca_id = dmp.personId and ra.event_id = dmp.eventId)
		LEFT JOIN dump.Competitions comp on dmp.competitionId = comp.id
		LEFT JOIN datalake.competitions cpn on dmp.competitionId = cpn.competition_id 
WHERE
	ra.average = dmp.average
    AND cpr.wca_name IS NOT NULL
	AND ra.state_id = ?
	AND ra.event_id = ?
ORDER BY ra.ranking ASC
`

type GetRankingAverageParams struct {
	Stateid string
	Eventid string
}

type GetRankingAverageRow struct {
	WcaID            string
	Name             string
	StateID          string
	Registered       int32
	EventID          string
	Ranking          int32
	Best             sql.NullInt32
	CompetitionID    sql.NullString
	CompetitionName  sql.NullString
	CompetitionState sql.NullString
	Time1            sql.NullInt32
	Time2            sql.NullInt32
	Time3            sql.NullInt32
	Time4            sql.NullInt32
	Time5            sql.NullInt32
	Ts               time.Time
}

func (q *Queries) GetRankingAverage(ctx context.Context, arg GetRankingAverageParams) ([]GetRankingAverageRow, error) {
	rows, err := q.db.QueryContext(ctx, getRankingAverage, arg.Stateid, arg.Eventid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRankingAverageRow
	for rows.Next() {
		var i GetRankingAverageRow
		if err := rows.Scan(
			&i.WcaID,
			&i.Name,
			&i.StateID,
			&i.Registered,
			&i.EventID,
			&i.Ranking,
			&i.Best,
			&i.CompetitionID,
			&i.CompetitionName,
			&i.CompetitionState,
			&i.Time1,
			&i.Time2,
			&i.Time3,
			&i.Time4,
			&i.Time5,
			&i.Ts,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRankingSingle = `-- name: GetRankingSingle :many
SELECT
	rs.wca_id 			AS wca_id,
	cpr.wca_name 		AS name,
	rs.state_id 		AS state_id,
	CASE WHEN ru.wca_id is not null THEN true ELSE false END AS registered,
	rs.event_id 		AS event_id,
	rs.ranking 			AS ranking,
	rs.single 			AS best,
	comp.id         	AS competition_id,
    comp.name       	AS competition_name,
    cpn.state_id  		AS competition_state,
    dmp.value1      	AS time_1,
    dmp.value2      	AS time_2,
    dmp.value3      	AS time_3,
    dmp.value4      	AS time_4,
    dmp.value5      	AS time_5,
    STR_TO_DATE(CONCAT(comp.year, ',', comp.endMonth, ',', comp.endDay), '%Y,%m,%d') AS ts
FROM
	datalake.ranking_single rs
		JOIN datalake.competitors cpr on rs.wca_id = cpr.wca_id
		LEFT JOIN app.registered_users ru on rs.wca_id = ru.wca_id
		LEFT JOIN dump.Results dmp on (rs.wca_id = dmp.personId and rs.event_id = dmp.eventId)
		LEFT JOIN dump.Competitions comp on dmp.competitionId = comp.id
		LEFT JOIN datalake.competitions cpn on dmp.competitionId = cpn.competition_id 
WHERE
	rs.single = dmp.best
    AND cpr.wca_name IS NOT NULL
	AND rs.state_id = ?
	AND rs.event_id = ?
ORDER BY rs.ranking ASC
`

type GetRankingSingleParams struct {
	Stateid string
	Eventid string
}

type GetRankingSingleRow struct {
	WcaID            string
	Name             string
	StateID          string
	Registered       int32
	EventID          string
	Ranking          int32
	Best             sql.NullInt32
	CompetitionID    sql.NullString
	CompetitionName  sql.NullString
	CompetitionState sql.NullString
	Time1            sql.NullInt32
	Time2            sql.NullInt32
	Time3            sql.NullInt32
	Time4            sql.NullInt32
	Time5            sql.NullInt32
	Ts               time.Time
}

func (q *Queries) GetRankingSingle(ctx context.Context, arg GetRankingSingleParams) ([]GetRankingSingleRow, error) {
	rows, err := q.db.QueryContext(ctx, getRankingSingle, arg.Stateid, arg.Eventid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRankingSingleRow
	for rows.Next() {
		var i GetRankingSingleRow
		if err := rows.Scan(
			&i.WcaID,
			&i.Name,
			&i.StateID,
			&i.Registered,
			&i.EventID,
			&i.Ranking,
			&i.Best,
			&i.CompetitionID,
			&i.CompetitionName,
			&i.CompetitionState,
			&i.Time1,
			&i.Time2,
			&i.Time3,
			&i.Time4,
			&i.Time5,
			&i.Ts,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStates = `-- name: GetStates :many
SELECT
    state_id,
    state_name
FROM
    app.states
`

func (q *Queries) GetStates(ctx context.Context) ([]AppState, error) {
	rows, err := q.db.QueryContext(ctx, getStates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppState
	for rows.Next() {
		var i AppState
		if err := rows.Scan(&i.StateID, &i.StateName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT
    wca_id,
    state_id,
    register_date
FROM
    app.registered_users
WHERE
    wca_id = ?
`

func (q *Queries) GetUser(ctx context.Context, wcaid string) (AppRegisteredUser, error) {
	row := q.db.QueryRowContext(ctx, getUser, wcaid)
	var i AppRegisteredUser
	err := row.Scan(&i.WcaID, &i.StateID, &i.RegisterDate)
	return i, err
}

const search = `-- name: Search :many
SELECT
	c.wca_id		AS wca_id,
	c.wca_name		AS wca_name,
	a.state_id		AS state_id
FROM
	datalake.competitors c
        LEFT JOIN datalake.all_persons_with_states a on c.wca_id = a.wca_id
WHERE
	c.wca_id LIKE ?
	OR c.wca_name LIKE ?
`

type SearchParams struct {
	Query string
}

type SearchRow struct {
	WcaID   string
	WcaName string
	StateID sql.NullString
}

func (q *Queries) Search(ctx context.Context, arg SearchParams) ([]SearchRow, error) {
	rows, err := q.db.QueryContext(ctx, search, arg.Query, arg.Query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchRow
	for rows.Next() {
		var i SearchRow
		if err := rows.Scan(&i.WcaID, &i.WcaName, &i.StateID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setUser = `-- name: SetUser :exec
INSERT INTO app.registered_users(
    wca_id, state_id, register_date
) VALUES (
    ?,
    ?,
    ?
)
ON DUPLICATE KEY UPDATE
    wca_id=wca_id, state_id=state_id, register_date=register_date
`

type SetUserParams struct {
	Wcaid        string
	Stateid      string
	Registerdate time.Time
}

func (q *Queries) SetUser(ctx context.Context, arg SetUserParams) error {
	_, err := q.db.ExecContext(ctx, setUser, arg.Wcaid, arg.Stateid, arg.Registerdate)
	return err
}
